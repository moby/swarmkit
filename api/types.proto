syntax = "proto3";

package api;

// NOTE(stevvooe): Make sure your gopath is appropriately set for this to work
// correctly.
import "github.com/gogo/protobuf/gogoproto/gogo.proto";

// Meta is common to all API objects types.
message Meta {
	// TODO(stevvooe): Consider an ID here. Probably not.

	string name = 1;
	map<string, string> labels = 2;
}

message NodeSpec {
	Meta meta = 1;

	// Addr provides an address for the node, accessible via the manager set.
	string addr = 2;

	// Status is the state of the node as seen by the creator the
	// specification. When reported by an agent, this will almost always be
	// READY or empty. When communicating through the Cluster API, this can be
	// used as a way to single the desired node state.
	NodeStatus status = 4;

	// TODO(stevvooe): Define resources for the node (ie cpu, memory, local
	// volumes, etc.).
}

message Node {
	// ID specifies the identity of the node.
	string id = 1 [(gogoproto.customname) = "ID"];

	NodeSpec spec = 2;

	// Status provides the current status of the node, as seen by the manager.
	// This may differ from the state in the nodespec.
	NodeStatus status = 3 [(gogoproto.nullable) = false];
}

message NodeStatus {
	enum State {
		// Unknown indicates the node state cannot be resolved.
		UNKNOWN = 0;

		// Down indicates the node is down.
		DOWN = 1;

		// Ready indicates the node is ready to accept tasks.
		READY = 2;

		// Drained indicates the node is actively a part of the cluster but is
		// not accepting new tasks.
		DRAINED = 3;
	}

	State state = 1;
	string message = 2;
}

message ImageSpec {
	// reference is a docker image reference. This can include a rpository, tag
	// or be fully qualified witha digest. The format is specified in the
	// distribution/reference package.
	string reference = 1; // TODO(stevvooe): Field type should be reference.Field.
}

message Source { // TODO(stevvooe): better name?
	oneof source {
		ImageSpec image = 1;
	}
}

// Spec defines the properties of a Job. As tasks are created, they gain the
// Job specification.
//
// There are two key components to a spec. The first is a "source". A source
// defines runnable content. For the swarm use case, this is a container but we
// may extend it to provide other kinds of runnable targets. The second
// component is the "orchestration". The orchestration defines the strategy
// used to the schedule and run the target with a cluster.
message JobSpec {
	Meta meta = 1;

	message ServiceJob {
		int64 instances = 1;
	}

	message BatchJob {
		int64 completions = 1;
		int64 paralellism = 2;
	}

	message GlobalJob {
	}

	message CronJob {
	}

	message Orchestration { // TODO(stevvooe): Consider calling this strategy.
		oneof job {
			ServiceJob service = 1;
			BatchJob batch = 2;
			GlobalJob global = 3;
			CronJob cron = 4;
		}
	}

	// NetworkAttachmentSpec describes a desired attachment to the named network or
	// a specific network_id.
	message NetworkAttachmentSpec {
		oneof reference {
			string name = 1;
			string network_id = 2 [(gogoproto.customname) = "NetworkID"];
		}
	}

	Source source = 2;
	Orchestration orchestration = 3;

	repeated NetworkAttachmentSpec networks = 4;

	// TODO(stevvooe): Specify the components that make up the container
	// configuration. This should have fields similar to container.Config.
}

message TaskStatus {
	enum State {
		NEW = 0;
		ALLOCATED = 1; // successfull allocation of resources that the task needs
		ASSIGNED = 2;
		PREPARING = 3;
		READY = 4;
		STARTING = 5;
		RUNNING = 6;
		SHUTDOWN = 7;
		COMPLETE = 8; // successful completion of task (not error code, just ran)
		FAILED = 9; // task execution failed with error
		REJECTED = 10; // task could not be executed here.
		FINALIZE = 11; // when task is deallocated from node, waiting on cleanup
		DEAD = 12; // completely finished, unallocated task.
	}

	State state = 2;
	string message = 3;
}

// Task specifies the parameters for implementing a Spec. A task is effectively
// immutable and idempotent. Once it is dispatched to a node, it will not be
// dispatched to another node.
message Task {
	string id = 1 [(gogoproto.customname) = "ID"];

	// JobID indicates the job under which this task is orchestrated. This
	// should almost always be set.
	string job_id = 2 [(gogoproto.customname) = "JobID"];

	// TODO(stevvooe): Consider bringing back assignment, rather than using a
	// node id field. We like having this concept be first-class. It helps to
	// reason about storage and consistency.

	// NodeID indicates the node to which the task is assigned. If this field
	// is empty or not set, the task is unassigned.
	string node_id = 4 [(gogoproto.customname) = "NodeID"];

	// NOTE(stevvooe): Spec, status or both may be set, depending on the role
	// of this message.

	JobSpec spec = 5;

	TaskStatus status = 7;

	// Resolved is the source resolved by the swarm cluster. This may be
	// identical, depending on the name provided in the JobSpec. For example,
	// the name field may be "redis", whereas this field would specify the
	// exact hash, "redis@sha256:...".
	Source resolved = 6;

	message NetworkAttachment {
		// Network state as a whole becomes part of Task so
		// that it always is available for use in agents so
		// that agents don't have any other dependency during execution.
		Network network = 1;

		// List of IPv4/IPv6 addresses that are assigned to the task
		// as part of getting attached to this network.
		repeated string addresses = 2;
	}

	repeated NetworkAttachment networks = 3;
}

message Job {
	string id = 1 [(gogoproto.customname) = "ID"];
	JobSpec spec = 3;
}

// IPAMConfiguration specifies parameters for IP Address Management.
message IPAMConfiguration {
	// TODO(stevvooe): It may make more sense to manage IPAM and network
	// definitions separately. This will allow multiple networks to share IPAM
	// instances. For now, we will follow the conventions of libnetwork and
	// specify this as part of the network specification.

	// Subnet defines a network as a CIDR address (ie network and mask
	// 192.168.0.1/24).
	string subnet = 1;

	// Range defines the portion of the subnet to allocate to tasks. This is
	// defined as a subnet within the primary subnet.
	string range = 2;

	// Gateway address within the subnet.
	string gateway = 3;

	// Reserved is a list of address from the master pool that should *not* be
	// allocated. These addresses may have already been allocated or may be
	// reserved for another allocation manager.
	map<string, string> reserved = 4;
}


// Driver is a generic driver type to be used throughout the API. For now, a
// driver is simply a name and set of options. The field contents depend on the
// target use case and driver application. For example, a network driver may
// have different rules than a volume driver.
message Driver {
	string name = 1;
	map <string, string> options = 2;
}

// NetworkSpec specifies user defined network parameters.
message NetworkSpec {
	Meta meta = 1;

	message IPAMOptions {
		Driver driver = 1;
		repeated IPAMConfiguration ipv4 = 3 [(gogoproto.customname) = "IPv4"];
		repeated IPAMConfiguration ipv6 = 4 [(gogoproto.customname) = "IPv6"];
	}

	// Driver specific configuration consumed by the network driver.
	Driver driver_configuration = 2;

	// IPv6Enabled enables support for IPv6 on the network.
	bool ipv6_enabled = 3;

	// internal restricts external access to the network. This may be
	// accomplished by disabling the default gateway or through other means.
	bool internal = 4;

	IPAMOptions ipam = 5 [(gogoproto.customname) = "IPAM"];
}

message Network {
	string id = 1 [(gogoproto.customname) = "ID"];
	NetworkSpec spec = 2;

	// Driver specific operational state provided by the network driver.
	Driver driver_state = 3;
}

// WeightedPeer should be used anywhere where we are describing a remote peer
// with a weight.
message WeightedPeer {
	string addr = 1;
	double weight = 2;

	// TODO(stevvooe): We must consolidate peer representation in the API.
}

